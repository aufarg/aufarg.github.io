<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>aufarg:/var/log $ _ - rant</title><link href="https://aufarg.github.io/" rel="alternate"></link><link href="https://aufarg.github.io/feeds/rant.atom.xml" rel="self"></link><id>https://aufarg.github.io/</id><updated>2017-11-28T17:05:18+07:00</updated><entry><title>Implementation vs Design</title><link href="https://aufarg.github.io/implementation-vs-design.html" rel="alternate"></link><published>2017-02-10T02:29:43+07:00</published><updated>2017-11-28T17:05:18+07:00</updated><author><name>Aufar Gilbran</name></author><id>tag:aufarg.github.io,2017-02-10:/implementation-vs-design.html</id><summary type="html">&lt;p&gt;In my school, there's a common dogma that software implementation is easy,
the hard part is designing. This dogma emerge as I take software engineering
classes. The lecturers keep a big emphasize on how cool to design a software
and how lame to implement a software. For me, I always â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;In my school, there's a common dogma that software implementation is easy,
the hard part is designing. This dogma emerge as I take software engineering
classes. The lecturers keep a big emphasize on how cool to design a software
and how lame to implement a software. For me, I always confused about that
dogma. Mostly because I don't know which processes are design and which are
implementation. But I asked my friends and they're confused too. So, I discuss
with my friends and came up with these thoughts.&lt;/p&gt;
&lt;p&gt;The definition given to me is implementation is a process to realized the
design and it's actually only the "coding" part. "Coding" here means to write
the code, that's it. But it doesn't make sense since the person who do the
design and the implementation is different. That means if the one who
implements only write the code, the design specification should consists of
detailed algorithm (that is, describe the program action by action) in another
language (most likely natural language or pseudocode).  It's weird because why
would the designer write the code in some language just to be rewritten again
in some programming language?&lt;/p&gt;
&lt;p&gt;Okay, maybe the language that's being used to create the design document is
easier to learn and "easier" to understand. But it's still inefficient
because no matter what language you write it with, the "coder" WILL ask you
about some part of the design (that is, the meaning particular sequence of
action) because you can't always translate an action between the design
document language and the programming language and the "coder" will need to
make sure that they have understand what you mean. This kind of
communication will slow down the development process and it's not efficient.&lt;/p&gt;
&lt;p&gt;One argument is that since the "coder" will have lower salary than the
designer (since "coding" is easier"), we can lower the budget too. Well, if
the design document is written action by action, the rate that design
document created will be the same as (if not longer than) the
implementation (designing requires thinking, "coding" can take a look at
reference). Unless we want the implementation be stuck waiting on the
design, we need to have many designer too so, no, we actually need more
budget (and still inefficient too).&lt;/p&gt;
&lt;p&gt;I guess I just misheard my lecturers and that's not what they meant. So I'll
just the one in
&lt;a href="https://en.wikipedia.org/wiki/Software_implementation"&gt;wikipedia&lt;/a&gt;: software
implementation (as a verb) is "the process of computer programming". The
&lt;a href="https://en.wikipedia.org/wiki/Computer_programming"&gt;computer programming&lt;/a&gt;
page defines programming as "activities such as analysis, developing
understanding, generating algorithms, verification of requirements of
algorithms including their correctness and resources consumption, and
implementation (commonly referred to as coding) of algorithms in a target
programming language".&lt;/p&gt;
&lt;p&gt;So, "coding" is part of implementation. But implementation includes so much
more than that. The person who do the implementation (let's call them the
programmer) will need to understand how the program will work. In fact,
according to the definition, the programmer's understanding of the language
also determines the correctness of the implementation. I think it's
also important to get the correctness of the implementation, not just the
correctness on the concept. Also, while concept is nice, sometimes
understanding of implementations can let you create a more practical concept
(even though messier) than the neat concept. This is the case (or at least
similar) with OSI vs IP described in &lt;a href="https://www.goodreads.com/book/show/166190.Computer_Networks"&gt;Computer
Networks&lt;/a&gt; by
Andrew Tanembaum.&lt;/p&gt;
&lt;p&gt;What I'm trying to say here is that software implementation does not
necessarily easier than software design, it may deal with something
deterministic and the answer is already there, but you still need to KNOW
the knowledge to do that. It may not require as much as creativity as
software designing, but hey, you won't say being a doctor is easy right?
(and if doctor use their creativity on their job, I'll be shit scared)&lt;/p&gt;
&lt;p&gt;But maybe it's just me that is too stupid to understand what my lecturers mean.
It's just, I'm sad that my school teaching me to lookdown on someone's job,
regardless if it's easier or not. I always think it's best to respect any
job and don't compare which is harder/cooler/profitable-r/yadayada, as
long as the job is doing something good to humanity.&lt;/p&gt;</content><category term="rant"></category></entry></feed>